@using WarHub.ArmouryModel.Source
@using WarHub.GodMode.Data

@inherits SourceNodeTreeItemBase

<div class="d-flex align-items-center">
    @if (HasChildren)
    {
        <a class="badge badge-light" role="button" @onclick="ToggleExpand">
            <span class="small oi @ExpandButtonIcon"></span>
        </a>
    }
    else
    {
        <span class="badge badge-light">
            <span class="small oi oi-ellipses"></span>
        </span>
    }
    <label class="flex-shrink-1 text-truncate mb-0 ml-1 @(Active ? "border border-primary" : "")"
           title="@Display.Name"
           style="min-width: 0; border: 1px solid transparent; user-select: none"
           tabindex="@(Active ? 0 : -1)"
           @ref="FocusableElementRef"
           @onclick="SelectNode"
           @ondblclick="ToggleExpand"
           @onkeydown="OnKeyDown"
           @onkeydown:preventDefault>
        <span class="position-relative">
            <span class="oi oi-@Display.Icon text-center" style="min-width: 1em"></span>
            @if (Display.ModIcon is { })
            {
                <span class="oi oi-@Display.ModIcon position-absolute p-1"
                      style="top: auto; bottom: -.5em; right: -.3em; transform: scale(0.5); border-radius: .3em; background-color: rgba(255, 255, 255, .8);"></span>
            }
        </span>
        @Display.Name
    </label>
    @if (HasChildren)
    {
        <span class="badge badge-secondary ml-1">
            @ChildItems.Length
        </span>
    }
</div>

@if (HasChildren && Expanded)
{
    <div class="ml-2 pl-2" style="border-left: 1px dotted grey;">
        @{
            var query = ChildGroups
                .Select(x => (startIndex: 0, group: x))
                .Scan((sum, item) => (startIndex: sum.startIndex + sum.group.nodes.Length, item.group));
        }
        @foreach (var (startIndex, @group) in query)
        {
            <small class="pl-3">@group.name</small>
            <ul class="list-unstyled">
                @foreach (var (index, child) in group.nodes.Index(startIndex))
                {
                    <li>
                        <SourceNodeTreeItem Node="@child" ParentItem="@this" IndexInParent="@index" />
                    </li>
                }
            </ul>
        }
    </div>
}

@code {
    SourceNode node;

    [Parameter]
    public SourceNode Node
    {
        get => node;
        set
        {
            if (node != value)
            {
                node = value;
                OnNodeChanged();
            }
        }
    }

    ImmutableArray<(string name, ImmutableArray<SourceNode> nodes)> ChildGroups { get; set; }

    string ExpandButtonIcon => Expanded ? "oi-minus" : "oi-plus";

    bool Active => Tree.ActiveItem == this;

    (string Name, string Icon, string ModIcon) Display { get; set; }

    static ImmutableHashSet<string> ExcludedListNames { get; } = new[]
    {
        nameof(SelectionEntryNode.Costs),
        nameof(SelectionEntryBaseNode.CategoryLinks),
        nameof(ProfileNode.Characteristics),
        nameof(ProfileTypeNode.CharacteristicTypes),
    }.ToImmutableHashSet();

    void OnNodeChanged()
    {
        ChildGroups = GetChildGroups().ToImmutableArray();
        HasChildren = ChildGroups.Length > 0;
        ChildItems = new SourceNodeTreeItem[ChildGroups.Sum(x => x.nodes.Length)];
        var di = NodeDisplayService.GetNodeDisplayInfo(Node);
        Display = (di.Name, di.Icon, di.IconModifier);
    }

    IEnumerable<(string name, ImmutableArray<SourceNode> nodes)> GetChildGroups()
    {
        var itemNameGroups = new[]
        {
            new[]
{
                nameof(SelectionEntryBaseCore.SelectionEntries),
                nameof(SelectionEntryBaseCore.SelectionEntryGroups),
                nameof(SelectionEntryBaseCore.EntryLinks),
            },
            new[]
{
                nameof(SelectionEntryBaseCore.Profiles),
                nameof(SelectionEntryBaseCore.Rules),
                nameof(SelectionEntryBaseCore.InfoGroups),
                nameof(SelectionEntryBaseCore.InfoLinks),
            },
            new[]
{
                nameof(EntryBaseCore.Modifiers),
                nameof(EntryBaseCore.ModifierGroups),
            }
        };
        var groups =
            from childInfo in Node.ChildrenInfos().Where(x => !ExcludedListNames.Contains(x.Name))
            join association in (
                from g in itemNameGroups
                from name in g
                select new
                {
                    groupName = g[0],
                    listName = name
                }) on childInfo.Name equals association.listName into assocGroup
            from assoc in assocGroup.DefaultIfEmpty(new { groupName = childInfo.Name, listName = childInfo.Name })
            group childInfo by assoc into listGroup
            let nodes = listGroup.SelectMany(x => x.Node.Children()).ToImmutableArray()
            where nodes.Length > 0
            select (name: listGroup.Key.groupName, nodes: nodes);
        return groups;
    }
}
