@using WarHub.ArmouryModel.Source
@using WarHub.GodMode.Data
@using WarHub.GodMode.Pages

<div class="d-flex align-items-center">
    <a class="btn btn-light btn-sm @ExpandInvisibleCss" role="button" @onclick="ToggleExpand">
        <span class="oi @ExpandButtonIcon"></span>
    </a>
    @{
        var name = GetName();
    }
    <label class="flex-shrink-1 text-truncate mb-0 ml-1 @(Active ? "border border-primary" : "")"
           title="@name"
           style="min-width: 5em; border: 1px solid transparent;"
           tabindex="@(Active ? 0 : -1)"
           @ref="NodeSpan"
           @onclick="SelectNode"
           @onkeydown="OnKeyDown"
           @onkeydown:preventDefault>
        <span class="oi oi-@NodeIcon"></span>
        @name
    </label>
    @if (@ChildItems.Length > 0)
    {
        <span class="badge badge-secondary ml-1">
            @ChildItems.Length
        </span>
    }
</div>

@if (HasChildren && Expanded)
{
    <div class="pl-3">
        @{
            var query = ChildGroups
                .Select(x => (startIndex: 0, group: x))
                .Scan((sum, item) => (startIndex: sum.startIndex + sum.group.nodes.Length, item.group));
        }
        @foreach (var (startIndex, @group) in query)
        {
            <em>@group.name</em>
            <ul class="list-unstyled">
                @foreach (var (index, child) in group.nodes.Index(startIndex))
                {
                    <li>
                        <SourceNodeTreeItem Node="@child" ParentItem="@this" IndexInParent="@index" />
                    </li>
                }
            </ul>
        }
    </div>
}

@code {
    private SourceNode node;

    [Parameter]
    public SourceNode Node
    {
        get => node;
        set
        {
            if (node != value)
            {
                node = value;
                OnNodeChanged();
            }
        }
    }

    [Parameter]
    public SourceNodeTreeItem ParentItem { get; set; }

    [Parameter]
    public int IndexInParent { get; set; } = -1;

    [CascadingParameter]
    public Catalogue Catalogue { get; set; }

    public ElementReference NodeSpan { get; private set; }

    private bool Expanded { get; set; }

    private bool HasChildren { get; set; }

    private ImmutableArray<(string name, ImmutableArray<SourceNode> nodes)> ChildGroups { get; set; }

    private SourceNodeTreeItem[] ChildItems { get; set; }

    private string ExpandButtonIcon => Expanded ? "oi-minus" : "oi-plus";

    private string ExpandInvisibleCss => !HasChildren ? "invisible" : "";

    private string NodeIcon => NodeDisplayService.GetNodeDisplayInfo(Node).Icon;

    private bool Active => Catalogue.ActiveNode == this.Node;

    private static ImmutableHashSet<string> ExcludedListNames { get; } = new[]
    {
        nameof(SelectionEntryNode.Costs),
        nameof(SelectionEntryBaseNode.CategoryLinks),
        nameof(ProfileNode.Characteristics),
        nameof(ProfileTypeNode.CharacteristicTypes),
    }.ToImmutableHashSet();

    void OnNodeChanged()
    {
        ChildGroups = GetChildGroups().ToImmutableArray();
        HasChildren = ChildGroups.Length > 0;
        ChildItems = new SourceNodeTreeItem[ChildGroups.Sum(x => x.nodes.Length)];
    }

    protected override void OnParametersSet()
    {
        if (Node == Catalogue.Root)
        {
            Expanded = true;
        }
        if (ParentItem is { })
        {
            ParentItem.ChildItems[IndexInParent] = this;
        }
    }

    string GetName()
    {
        return NodeDisplayService.GetNodeDisplayInfo(Node).Name;
    }

    async Task ToggleExpand()
    {
        if (!HasChildren)
        {
            return;
        }
        Expanded = !Expanded;
        if (!Expanded && this.Node.Contains(Catalogue.ActiveNode))
        {
            await SelectNode();
        }
    }

    async Task SelectNode()
    {
        await Catalogue.SelectNode(this);
    }

    IEnumerable<(string name, ImmutableArray<SourceNode> nodes)> GetChildGroups()
    {
        var itemNameGroups = new[]
        {
            new[]
{
                nameof(SelectionEntryBaseCore.SelectionEntries),
                nameof(SelectionEntryBaseCore.SelectionEntryGroups),
                nameof(SelectionEntryBaseCore.EntryLinks),
            },
            new[]
{
                nameof(SelectionEntryBaseCore.Profiles),
                nameof(SelectionEntryBaseCore.Rules),
                nameof(SelectionEntryBaseCore.InfoGroups),
                nameof(SelectionEntryBaseCore.InfoLinks),
            },
            new[]
{
                nameof(EntryBaseCore.Modifiers),
                nameof(EntryBaseCore.ModifierGroups),
            }
        };
        var groups =
            from childInfo in Node.ChildrenInfos().Where(x => !ExcludedListNames.Contains(x.Name))
            join association in (
                from g in itemNameGroups
                from name in g
                select new
                {
                    groupName = g[0],
                    listName = name
                }) on childInfo.Name equals association.listName into assocGroup
            from assoc in assocGroup.DefaultIfEmpty(new { groupName = childInfo.Name, listName = childInfo.Name })
            group childInfo by assoc into listGroup
            let nodes = listGroup.SelectMany(x => x.Node.Children()).ToImmutableArray()
            where nodes.Length > 0
            select (name: listGroup.Key.groupName, nodes: nodes);
        return groups;
    }

    async Task OnKeyDown(KeyboardEventArgs e)
    {
        const int pageSteps = 10;
        await (e.Key switch
        {
            "ArrowLeft" => GoLeft(),
            "ArrowUp" => GoUp(1),
            "ArrowRight" => GoRight(),
            "ArrowDown" => GoDown(1),
            "Home" => GoHome(),
            "End" => GoEnd(),
            "PageUp" => GoUp(pageSteps),
            "PageDown" => GoDown(pageSteps),
            "*" => ExpandSiblings(),
            _ => Task.CompletedTask
        });
    }

    async Task GoLeft()
    {
        if (Expanded)
        {
            await ToggleExpand();
        }
        else
        {
            await ParentItem?.SelectNode();
        }
    }

    async Task GoRight()
    {
        if (!Expanded)
        {
            await ToggleExpand();
        }
        else
        {
            await ChildItems[0].SelectNode();
        }
    }

    async Task GoUp(int steps)
    {
        var x = this;
        for (int i = 0; i < steps; i++)
        {
            x = GetPrevious(x);
        }
        await x.SelectNode();

        static SourceNodeTreeItem GetPrevious(SourceNodeTreeItem item)
        {
            if (item.IndexInParent == 0)
            {
                return item.ParentItem;
            }
            else if (item.IndexInParent > 0)
            {
                var prev = item.ParentItem.ChildItems[item.IndexInParent - 1];
                while (prev.Expanded)
                {
                    prev = prev.ChildItems[^1];
                }
                return prev;
            }
            return item;
        }
    }

    async Task GoDown(int steps)
    {
        var x = this;
        for (int i = 0; i < steps; i++)
        {
            x = GetNext(x);
        }
        await x.SelectNode();

        static SourceNodeTreeItem GetNext(SourceNodeTreeItem item)
        {
            if (item.Expanded)
            {
                return item.ChildItems[0];
            }
            if (item.IndexInParent + 1 < item.ParentItem?.ChildItems.Length)
            {
                return item.ParentItem.ChildItems[item.IndexInParent + 1];
            }
            else
            {
                var next = item;
                while (next.IndexInParent + 1 == next.ParentItem?.ChildItems.Length)
                {
                    next = next.ParentItem;
                }
                if (next.ParentItem is { })
                {
                    return next.ParentItem.ChildItems[next.IndexInParent + 1];
                }
                return item;
            }
        }
    }

    async Task GoHome()
    {
        var first = this;
        while (first.IndexInParent >= 0)
        {
            first = first.ParentItem;
        }
        await first.SelectNode();
    }

    async Task GoEnd()
    {
        var first = this;
        while (first.IndexInParent >= 0)
        {
            first = first.ParentItem;
        }
        var last = first;
        while (last.Expanded)
        {
            last = last.ChildItems[^1];
        }
        await last.SelectNode();
    }

    async Task ExpandSiblings()
    {
        if (ParentItem is null)
        {
            return;
        }
        foreach (var item in ParentItem.ChildItems)
        {
            if (!item.Expanded && item.HasChildren)
            {
                await item.ToggleExpand();
                item.StateHasChanged();
            }
        }
    }
}
